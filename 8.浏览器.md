### 浏览器的主要组成部分是什么？

1. **用户界面**

   包括地址栏、前进/后退按钮、书签菜单等。除了浏览器主窗口显示的您请求的页面外，其他显示的各个部分都属于用户界面

2. **浏览器引擎**

   在用户界面和呈现引擎之间传送指令

3. **呈现引擎**

   负责显示请求的内容。如果请求的内容是 HTML，它就负责解析 HTML 和 CSS 内容，并将解析后的内容显示在屏幕上

4. **网络**

   用于网络调用，比如 HTTP 请求。其接口与平台无关，并为所有平台提供底层实现

5. **用户界面后端**

   用于绘制基本的窗口小部件，比如组合框和窗口。其公开了与平台无关的通用接口，而在底层使用操作系统的用户界面方法。

6. **JavaScript 解释器**

   用于解析和执行 JavaScript 代码。

7. **数据存储**

   这是持久层。浏览器需要在硬盘上保存各种数据，例如 Cookie。新的 HTML 规范 (HTML5) 定义了“网络数据库”，这是一个完整（但是轻便）的浏览器内数据库





### Chrome 打开一个页面需要启动多少进程？分别有哪些进程？

* **关闭状态进行启动，然后新开 1 个页面**

  1 个网络进程、1 个浏览器进程、1 个 GPU 进程以及 1 个渲染进程，多个插件进程

* **后续新开页面**

  * `浏览器进程`、`网络进程`、`GPU进程`是共享的，不会重新启动
  * 且从a页面中打开的b页面，那么他们也会共用一个`渲染进程`，否则新开一`新渲染进程`

* **各个进程的作用**

  * **网络进程**

    主要负责页面的网络资源加载，之前是作为一个模块运行在浏览器进程里面的，直至最近才独立出来，成为一个单独的进程

  * **浏览器进程**

    主要负责界面显示、用户交互、子进程管理，同时提供存储等功能

  * **GPU 进程**

    GPU的使用初衷是为了实现`3D CSS`的效果，只是随后`网页`、Chrome 的 `UI 界面`都选择采用 GPU 来绘制

  * **渲染进程**

    将 HTML、CSS 和 JavaScript 转换为用户可以与之交互的网页、排版引擎 `Blink` 和 `JavaScript` 引擎 V8 都是运行在该进程中。出于安全考虑，渲染进程都是运行在沙箱模式下

  * **插件进程**

    因插件易崩溃，所以需要通过插件进程来隔离，以保证插件进程崩溃不会对浏览器和页面造成影响



### 浏览器渲染进程中有什么线程

1. GUI 渲染线程
2. JS 引擎线程
3. 定时器触发线程 (setTimeout)
4. 浏览器事件线程 (onclick)
5. http 异步线程
6. EventLoop轮询处理线程



### 为什么很多站点第二次打开速度会很快？

主要原因是第一次加载页面过程中，缓存了一些耗时的数据。 那么，哪些数据会被缓存呢？

* **DNS缓存**

* **MemoryCache**

  是指存在内存中的缓存。从优先级上来说，它是浏览器最先尝试去命中的一种缓存。从效率上来说，它是响应速度最快的一种缓存。 内存缓存是快的，也是“短命”的。它和渲染进程“生死相依”，当进程结束后，也就是 tab 关闭以后，内存里的数据也将不复存在。

* **浏览器缓存**

  强缓存，浏览器缓存



### 谈谈浏览器缓存

* **是什么**

  浏览器缓存是浏览器在本地磁盘对用户最近请求过的文档进行存储，当访问者再次访问同一页面时，浏览器就可以直接从本地磁盘加载文档

* **为什么**

  1. 减少冗余的数据传输
  2. 减少服务器负担
  3. 加快客户端加载网页的速度

* **强缓存**

  * 强缓存是利用http头中的`Expires`和`Cache-Control`两个字段来控制的，用来表示资源的缓存时间

  * **只有当在地址栏或收藏夹输入网址、通过链接引用资源等情况下，浏览器会启用强缓存**

  * 可以通过强制刷新`ctrl+f5`来清除强缓存，此时请求带上的是`Cache-Control:no-cache`和`Pragma:no-cache`

  * 如果同时出现`Cache-Control`和`Expires`，那么`Cache-Control`优先级更高

* **协商缓存**

  * 协商缓存就是由`服务器来确定`缓存资源是否可用，所以客户端与服务器端要通过某种标识来进行通信，从而让服务器判断请求资源是否可以缓存访问
  * 普通刷新时只使用协商缓存
  * **Etag和If-None-Match**`(优先)`
  * **Last-Modify/If-Modify-Since**
  * 上面两个命中了都返回304

* **协商缓存为何要有Etag**
  * 一些文件也许会周期性的更改，但是他的内容并不改变(仅仅改变的修改时间)，这个时候我们并不希望客户端认为这个文件被修改了，而重新GET，所以用`Etag`
  * **某些文件修改非常频繁**，比如在秒以下的时间内进行修改，(比方说1s内修改了N次)，If-Modified-Since能检查到的粒度是s级的，这种修改无法判断(或者说UNIX记录MTIME只能精确到秒)；
  * 某些服务器不能精确的得到文件的最后修改时间

![H4lWfU.png](https://s4.ax1x.com/2022/02/17/H4lWfU.png)







### 获取浏览器URL的一些内容

* location.href

  返回或设置当前文档的URL

* location.protocol

  返回URL中的协议部分

* location.host

  返回URL中的域名部分,例如[www.dreamdu.com](http://www.dreamdu.com/)

* location.hostname

  返回URL中的主域名部分,例如dreamdu.com

* location.port

  返回URL中的端口部分

* location.pathname

  返回URL的域名后的部分

* location.search 

  返回URL中的查询字符串部分

* location.hash

  返回URL#后面的内容，如果没有#，返回空

* location.assign

  设置当前文档的URL

* location.replace()

  设置当前文档的URL，并且在history对象的地址列表中移除这个URL 

* location.reload() -- 重载当前页面







### cookie是什么，有哪些字段

* **是什么**

  - cookie 是存储于访问者计算机中的变量。每当一台计算机通过浏览器来访问某个页面时，那么就可以通过 JavaScript 来创建和读取 cookie。
  - 实际上 cookie 是存于用户硬盘的一个文件，这个文件通常对应于一个域名，当浏览器再次访问这个域名时，便使这个cookie可用。
  - 不同浏览器对 cookie 的实现也不一样。即保存在一个浏览器中的 cookie 到另外一个浏览器是不能获取的。

* **字段**

  ```js
  document.cookie = "name=value;expires=evalue; path=pvalue; domain=dvalue; secure;”
  ```

  * name（必选）
  * expires（只支持GTM 标准时间，不设置的话默认值是Session，意思是cookie会和session一起失效）
  * path
  * size
  * domain（如果没有设置，则默认在当前域名访问，也就是设置cookie的域名）、
  * secure（只能以https传输）
  * http(设置为httpOnly之后改cookie不能由document.cookie来访问)

### cookie sessionStorage localStorage区别

* **传递**

  cookie始终在同源的http请求中携带，其他两个不会。cookie有path的概念，可以使cookie只保存在某个路径下

* **大小**

  cookie一般不会超过4k，因为在同源请求中携带。其他两个可以达到5M甚至更多。

* **有效期**

  cookie在设置的过期时间之前有效，即使窗口关闭或浏览器关闭，若没设置，则为0；sessionStorage：仅在当前浏览器窗口关闭之前有效；localStorage：始终有效，窗口或浏览器关闭也一直保存，因此用作持久数据；

* **作用域**

  cookie在所有同源窗口中共享；sessionStorage在同一个浏览器窗口是共享的（点击链接或者用window.open打开也算）；localStorage：在所有同源窗口中共享；

  



### cookie session区别

1. cookie数据存放在客户的浏览器上，session数据放在服务器上
2. cookie不够安全，考虑到安全性，应该用session
3. session会在一定时间内保存在服务器上。当访问增多，会比较占用你服务器的性能,考虑到减轻服务器性能方面，应当使用COOKIE





### 如何写一个会过期的localStorage，说说想法

* **惰性删除**

  给存放的localStorage同时存放一个时间，过期之后不会立即被删除，下次使用到的时候检查，过期了就删除

  > 如果一直没被用到，就会浪费内存

* **定时删除**

  定时删除是指，每隔一段时间执行一次删除操作，并通过限制删除操作执行的次数和频率，来减少删除操作对CPU的长期占用。

  1. 随机测试20个设置了过期时间的key
  2. 删除所有发现的已过期的key
  3. 若删除的key超过5个则重复**步骤1**，直至重复500次





###  localStorage 能跨域吗

**不能**

* **解决方案**
  1. 通过postMessage来实现跨源通信
  2. 可以实现一个公共的iframe部署在某个域名中，作为共享域
  3. 将需要实现localStorage跨域通信的页面嵌入这个iframe
  4. 接入对应的SDK操作共享域，从而实现localStorage的跨域存储

<img src="https://uploadfiles.nowcoder.com/images/20220301/4107856_1646126546442/3249E83F169E79A33FEC19E76D6080F6" alt="img" style="zoom: 67%;" />





### 输入一个URl之后发生了什么

1. **URL解析**

   首先需要找到这个url域名的`服务器ip`,为了寻找这个ip，浏览器首先会寻找`缓存`。`浏览器缓存` -> `系统缓存`-> `路由器缓存`。缓存中没有则查找系统的hosts文件中是否有记录,如果没有则查询DNS服务器

2. **TCP连接**

   根据 IP 地址，客户端与服务端进行三次握手，建立连接

3. **处理请求**

   连接后，创建一个http请求，这个请求报文会包括这次请求的信息，主要是**请求方法，请求说明和请求附带的数据**，并将这个http请求封装在一个tcp包中。这个tcp包会依次经过`传输层`，`网络层`，`数据链路层`，`物理层`到达服务器，服务器解析这个请求来作出响应，返回相应的html(`树形`)给浏览器

4. **接受响应渲染页面**
   * 浏览器根据返回的html来构建DOM树，在DOM树的构建过程中如果遇到JS脚本和外部JS链接，则会停止构建DOM树来执行和下载相应的代码。
   * 之后根据外部样式，内部样式，内联样式构建一个CSS对象模型树CSSOM树，构建完成后和DOM树合并为渲染树（render tree）。
   * 生成布局(flow)，浏览器在屏幕上“画”出渲染树中的所有节点；
   * 将布局绘制(paint)在屏幕上，显示出整个页面。





### 重排，重绘的区别、如何避免

* **区别**

  * **重排**：当`DOM`的变化影响了元素的几何信息(`DOM`对象的位置和尺寸大小)，浏览器需要重新计算元素的几何属性，重新构造渲染树，这个过程叫做重排。

    > * 添加、删除可见的dom
    > * 元素的位置改变
    > * 元素的尺寸改变(外边距、内边距、边框厚度、宽高、等几何属性)
    > * 浏览器窗口尺寸改变
    > * 获取某些属性。当获取一些属性时，浏览器为取得正确的值也可能会触发重排,因为它会导致队列刷新（浏览器要获取最新的这些值），这些属性包括：offsetTop、offsetLeft、 offsetWidth、offsetHeight、scrollTop、scrollLeft、scrollWidth、scrollHeight、clientTop、clientLeft、clientWidth、clientHeight、getComputedStyle() (currentStyle in IE)。所以，在多次使用这些值时应进行缓存。

  * **重绘：**当一个元素的外观发生改变，但没有改变布局,重新把元素外观绘制出来的过程，叫做重绘

  * **重绘不一定需要重排，重排必然导致重绘**

* **优化建议**

  1. **样式集中改变**

     可以更改类名而不是修改样式: `style.cssText或者classname`

  2. **分离读写操作**

     每次读上面说的那些属性，都会导致浏览器的队列刷新，如果书刷新的时候发现有修改，那么就会重排

     ```js
     // bad 强制刷新 触发四次重排+重绘
     div.style.left = div.offsetLeft + 1 + 'px';
     div.style.top = div.offsetTop + 1 + 'px';
     div.style.right = div.offsetRight + 1 + 'px';
     div.style.bottom = div.offsetBottom + 1 + 'px';
     
     // 读的时候虽然会刷新，但是没有样式改变，不会重排重绘
     // 注意，还是刷新了的
     var curLeft = div.offsetLeft;
     var curTop = div.offsetTop;
     var curRight = div.offsetRight;
     var curBottom = div.offsetBottom;
     
     div.style.left = curLeft + 1 + 'px';
     div.style.top = curTop + 1 + 'px';
     div.style.right = curRight + 1 + 'px';
     div.style.bottom = curBottom + 1 + 'px';
     ```
  
  4. **将要修改的DOM元素离线操作**
  
     * **使用 display:none**
  
       一旦我们给元素设置 `display:none` 时（只有一次重排重绘），元素便不会再存在在渲染树中，相当于将其从页面上“拿掉”，我们之后的操作将不会触发重排和重绘，添加足够多的变更后，通过 `display`属性显示
  
     * **创建碎片**
  
       通过 [documentFragment](https://link.juejin.cn/?target=https%3A%2F%2Fdeveloper.mozilla.org%2Fzh-CN%2Fdocs%2FWeb%2FAPI%2FDocumentFragment) 创建一个 `dom` 碎片,在它上面批量操作 `dom`，操作完成之后，再添加到文档中，这样只会触发一次重排。
  
     * **复制节点**
  
       复制节点【cloneNode(deep)】，在副本上工作，然后替换`replaceChild(newNode,oldNode)`
  
     * **脱离文档流**
  
       使用绝对定位会使的该元素单独成为渲染树中 `body` 的一个子元素，重排开销比较小，不会对其它节点造成太多影响



### transform会重绘吗，为什么

`transform` 不重绘，不回流 是因为`transform`属于合成属性，对合成属性进行`transition/animate`动画时，将会创建一个合成层。这使得动画元素在一个独立的层中进行渲染。当元素的内容没有发生改变，就没有必要进行重绘。浏览器会通过重新`复合`来创建`动画帧`。



### 浏览器的垃圾回收机制

* **是什么**
  * 浏览器的 Javascript 具有自动垃圾回收机制，也就是说，执行环境会负责管理代码执行过程中使用的内存。其原理是：**垃圾收集器会定期（周期性）找出那些不在继续使用的变量，然后释放其内存**。
  * **垃圾收集器必须跟踪到底哪个变量没用，对于不再有用的变量打上标记，以备将来收回其内存**。用于标记的无用变量的策略可能因实现而有所区别，通常情况下有两种实现方式：**标记清除**和**引用计数**。引用计数不太常用，标记清除较为常用。

*  **标记清除**

  * 当变量进入环境时，例如，在函数中声明一个变量，就将这个变量标记为“进入环境”。从逻辑上讲，永远不能释放进入环境的变量所占用的内存，因为只要执行流进入相应的环境，就可能会用到它们。而当变量离开环境时，则将其标记为“离开环境”。

    ```js
    function test(){
    	var a = 10 ;             //被标记 ，进入环境 
    	var b = 20 ;             //被标记 ，进入环境
    }
    test();                     //执行完毕 之后 a、b又被标离开环境，被回收。
    ```

  * 垃圾回收器在运行的时候会给存储在内存中的所有变量都加上标记。然后，它会去掉环境中的变量以及被环境中的变量引用的变量的标记（闭包）
  * 在此之后再还存在标记的变量将被视为准备删除的变量，原因是环境中的变量已经无法访问到这些变量了。
  * 最后，垃圾回收器完成内存清除工作，销毁那些带标记的值并回收它们所占用的内存空间

* **引用计数法**

  * 跟踪记录每个值被引用的次数

  * 当声明了一个变量并将一个引用类型值赋给该变量时，则这个值的引用次数就是1

  * 如果同一个值又被赋给另一个变量，则该值的引用次数加1;相反，如果包含对这个值引用的变量又取得了另外一个值，则这个值的引用次数减1。

    ```js
    function test(){
        var a = {} ;         //a的引用次数为0 
        var b = a ;         //a的引用次数加1，为1 
        var c =a;           //a的引用次数再加1，为2
        var b ={};          //a的引用次数减1，为1
    }
    ```

  * 当这个值的引用次数变成0时，则说明没有办法再访问这个值了，因而就可以将其占用的内存空间回收回来。这样，当垃圾回收器下次再运行时，它就会释放那些引用次数为0的值所占用的内存。

  * 有个很大的问题就是循环引用

    > 下面代码a和b的引用次数都是2，fn()执行完毕后，两个对象都已经离开环境，在标记清除方式下是没有问题的，但是在引用计数策略下，因为a和b的引用次数不为0，所以不会被垃圾回收器回收内存，如果fn函数被大量调用，就会造成内存泄露

    > 可以手动将变量设置为null以解除循环引用

    ```js
    function fn() {
        var a = {};
        var b = {};
        a.pro = b;
        b.pro = a;
    }
    fn();
    ```





### 垃圾回收机制的缺陷和优化策略

* **缺陷**

  GC时，停止响应其他操作，这是为了安全考虑。而Javascript的GC在100ms甚至以上，对一般的应用还好，但对于JS游戏，动画对连贯性要求比较高的应用，就麻烦了。所以要避免GC造成的长时间停止响应

* **GC优化策略**

  1. **分代回收**

     目的是通过区分“临时”与“持久”对象；多回收“临时对象”区（young generation），少回收“持久对象”区（tenured generation），减少每次需遍历的对象，从而减少每次GC的耗时。

     ![img](https://uploadfiles.nowcoder.com/images/20220301/4107856_1646126640705/7D4522C51A49ACD678DF8741491B5402)

     

  2. **增量GC**

     就是“每次处理一点，下次再处理一点，如此类推”。如图

     这种方案，虽然耗时短，但中断较多，带来了上下文切换频繁的问题。

     ![img](https://uploadfiles.nowcoder.com/images/20220301/4107856_1646126654911/A00ABEC86286C7CA07246A7E6B1A60A0)





### 浏览器调试工具

1. Elements：可查看网页页面代码（修改只是当前使用有效），也可实时调试修改页面ccs代码样式。
2. console：记录开发者开发过程中的日志信息，也可在里面写js代码。一般页面运行时js报错都是可以在这里看到反馈和定位bug原因及其位置。
3. Sources：断点调试JS，可以查看程序代码执行的过程，断点调试对于每一个程序员来说可是很重要。
4. Network：从发起网页页面请求开始，分析HTTP请求后得到的各个请求资源信息
5. Timeline：记录并分析网站的生命周期所发生的各类事件，分析渲染js执行的每一个阶段。
6. Application：记录网站加载的各个资源信息。
7. Security：判断网页是否安全。
8. Audits：对当前网页的网络利用及网页性能进行检测，并给出一些优化建议。





### WebWoker 

* 在HTML页面中，如果在执行脚本时，页面的状态是不可响应的，直到脚本执行完成后，页面才变成可响应。web worker是运行在后台的js，独立于其他脚本，不会影响页面的性能
* 并且通过postMessage将结果回传到主线程。这样在进行复杂操作的时候，就不会阻塞主线程了。





### 什么是SEO

搜索引擎优化。利用搜索引擎的规则提高网站在有关搜索引擎内的自然排名



### Doctype作用?严格模式与混杂模式如何区分？它们有何意义?

Doctype声明于文档最前面，告诉浏览器以何种方式来渲染页面，这里有两种模式，严格模式和混杂模式

1. 严格模式的排版和运作模式是以该浏览器支持的最高标准运行
2. 混杂模式，向后兼容，模拟老式浏览器，防止浏览器无法兼容页面





### 有哪些BOM属性

1. **location对象**

2. **history对象**

   * history.go()

     前进或后退指定的页面数 history.go(num);

   * history.back() -- 后退一页

   * history.forward() -- 前进一页

3. **Navigator对象**

   * navigator.userAgent

     返回用户代理头的字符串

   * navigator.cookieEnabled

     返回浏览器是否支持(启用)cookie



### 什么是跨域

跨域是浏览器的一个特性，就是浏览器从一个“域”向另一个“域”的服务器发出请求，来访问另一个“域”上的资源。但是，由于请求的文件可能会存在恶意攻击，浏览器并不允许直接访问另一个“域”上的资源，只能访问同一个“域”上的资源，这个就是“同源策略”。而所谓的“同源”，指的是“协议、域名、端口号”一致。





### JS实现跨域

* **jsonp跨域**

  利用`<script>`标签没有跨域限制的漏洞，网页可以得到从其他来源动态产生的 JSON 数据。JSONP请求一定 需要对方的服务器做支持才可以。但是只支持get。

  ```js
  声明一个回调函数，其函数名(如show)当做参数值，要传递给跨域请求数据的服务器，函数形参为要获取目 标数据(服务器返回的data)。
  
  创建一个``标签，把那个跨域的API数据接口地址，赋值给script的src,还要在这个地址中向服务器传递该函数 名（可以通过问号传参:?callback=show）。
  
  服务器接收到请求后，需要进行特殊的处理：把传递进来的函数名和它需要给你的数据拼接成一个字符串,例 如：传递进去的函数名是show，它准备好的数据是show('我不爱你')。
  
  最后服务器把准备的数据通过HTTP协议返回给客户端，客户端再调用执行之前声明的回调函数（show），对 返回的数据进行操作。
  ```

* **CORS**

  服务端设置Access-Control-Allow-Origin即可

* **代理跨域**

  启一个代理服务器，实现数据的转发

* **postMessage跨域**

  postMessage是HTML5 XMLHttpRequest Level 2中的API，且是为数不多可以跨域操作的window属性之一，它可用于解决以下方面的问题：
  
  1. 页面和其打开的新窗口的数据传递
  2. 多窗口之间消息传递
  3. 页面与嵌套的iframe消息传递
  4. 上面三个场景的跨域数据传递

* **websocket**

  **WebSocket 的 server 与 client 都能主动向对方发送或接收数据**。同时，WebSocket 在建立连接时需要借助 HTTP 协议，连接建立好了之后 client 与 server 之间的双向通信就与 HTTP 无关了。

* **window.name + iframe**

  window.name属性的独特之处：name值在不同的页面（甚至不同域名）加载后依旧存在，并且可以支持非常长的 name 值（2MB）。

  > 通过iframe的src属性由外域转向本地域，跨域数据即由iframe的window.name从外域传递到本地域。

* **location.hash + iframe**

  a.html欲与c.html跨域相互通信，通过中间页b.html来实现。 三个页面，不同域之间利用iframe的location.hash传值，相同域之间直接js访问来通信。

* **document.domain + iframe**

  **该方式只能用于二级域名相同的情况下，比如a.test.com和b.test.com适用于该方式**。 只需要给页面添加document.domain ='test.com'表示二级域名都相同就可以实现跨域。





### URL是什么

**URI**是一个用于标识互联网资源名称的字符串。 该种标识允许用户对网络中（一般指[万维网](https://link.jianshu.com/?t=https://zh.wikipedia.org/wiki/万维网)）的资源通过特定的协议进行交互操作。



