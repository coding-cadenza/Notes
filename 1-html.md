

### html标签的类型（head， body，！Doctype） 他们的作用是什么

* head
  - 是所有头部元素的容器, 绝大多数头部标签的内容不会显示给读者
  - 该标签下所包含的部分可加入的标签有...
* body
  - 用于定义文档的主体, 包含了文档的所有内容
  - 该标签支持 html 的全局属性和事件属性
* !DOCTYPE 标签
  - 它是指示 web 浏览器关于页面使用哪个 HTML 版本进行编写的指令.



### H5新特性

* 新增选择器 document.querySelector、document.querySelectorAll

* 拖拽释放(Drag and Drop) API

* 媒体播放的 video 和 audio

* 本地存储 localStorage 和 sessionStorage

* 语意化标签 article、footer、header、nav、section

* 增强表单控件 date、time、email、url、search、color

  > 一般都是自定义规则

* 离线应用 manifest

* 桌面通知 Notifications

* 多任务 webworker

* 全双工通信协议 websocket

* 历史管理 history

* 跨域资源共享(CORS) Access-Control-Allow-Origin

* 页面可见性改变事件 visibilitychange

* FormData 对象

* 绘画 canvas



### 介绍一下语义化标签和优点

在HTML5出来之前，我们习惯于用div来表示页面的章节或者不同模块，但是div本身是没有语义的。但是现在，HTML5中加入了一些语义化标签，来更清晰的表达文档结构。

主要的语义化标签和作用如下

```html
<header>     <!--：页眉通常包括网站标志、主导航、全站链接以及搜索框。-->
<nav>        <!--：标记导航，仅对文档中重要的链接群使用。-->
<main>         <!--：页面主要内容，一个页面只能使用一次。如果是web应用，则包围其主要功能。-->
<article>    <!--：定义外部的内容，其中的内容独立于文档的其余部分。-->
<section>    <!--：定义文档中的节（section、区段）。比如章节、页眉、页脚或文档中的其他部分。-->
<aside>         <!--：定义其所处内容之外的内容。如侧栏、文章的一组链接、广告、友情链接、相关产品列表等。-->
<footer>     <!--：页脚，只有当父级是body时，才是整个页面的页脚。-->
```

语义化优点：

- 易于用户阅读，样式丢失的时候能让页面呈现清晰的结构。
- 有利于SEO，搜索引擎根据标签来确定上下文和各个关键字的权重。
- 方便屏幕阅读器解析，如盲人阅读器根据语义渲染网页
- 有利于开发和维护，语义化更具可读性，代码更好维护，与CSS3关系更和谐。





### 介绍一下audio标签

* **常用属性**

  | 属性     | 属性值   | 注释                                                         |
  | -------- | -------- | ------------------------------------------------------------ |
  | src      | url      | 播放的音乐的url地址                                          |
  | preload  | preload  | 预加载（在页面被加载时进行加载或者说缓冲音频），如果使用了autoplay的话那么该属性失效。 |
  | loop     | loop     | 循环播放                                                     |
  | controls | controls | 是否显示默认控制条（控制按钮）                               |
  | autoplay | autoplay | 自动播放                                                     |

* **js属性**

  | 属性     | 解释                                                   |
  | -------- | ------------------------------------------------------ |
  | duration | 获取媒体文件的总时长，以s为单位，如果无法获取，返回NaN |
  | muted    | 用来获取或设置静音状态。值为boolean                    |
  
* **控制属性函数**

  | 函数             | 作用                                                 |
  | ---------------- | ---------------------------------------------------- |
  | load()           | 加载视频，音频                                       |
  | play()           | 加载并播放音频、视频文件或重新播放暂停的的音频、视频 |
  | canPlayType(obj) | 测试是否支持给定的Mini类型的文件                     |

* **常用事件**

  | 事件           | 事件作用                                           |
  | -------------- | -------------------------------------------------- |
  | loadstart      | 客户端开始请求数据                                 |
  | progress       | 客户端正在请求数据（或者说正在缓冲）               |
  | play           | play()和autoplay播放时                             |
  | pause          | pause()方法促发时                                  |
  | ended          | 当前播放结束                                       |
  | timeupdate     | 当前播放时间发生改变的时候。播放中常用的时间处理哦 |
  | canplaythrough | 歌曲已经载入完全完成                               |
  | canplay        | 缓冲至目前可播放状态。                             |





###  link 和 @import

* **共同作用**

  导入样式

  ```js
  <style type="text/css">
  @import url(index.css);
  </style>
  ```

* **区别**

  1. 引入的内容不同

     > link 除了引用样式文件，还可以引用图片等资源文件，而 @import 只引用样式文件

  2. 加载顺序不同

     > link 引用 CSS 时，在页面载入时同时加载；@import 需要页面网页完全载入以后加载

  3. 兼容性不同

     > link 是 XHTML 标签，无兼容问题；@import 是在 CSS2.1 提出的，低版本的浏览器不支持

  4. 对 JS 的支持不同

     > link 支持使用 Javascript 控制 DOM 去改变样式；而 @import 不支持
     >
     > 就是平时在js中改变样式



### href和src的区别

* **请求资源类型不同**
  * href表示超文本引用。用来**建立当前元素和文档之间的链接**。常用的有：*link、a*
  * 在请求 src 资源时会**将其指向的资源下载**并应用到文档中，常用的有*script，img 、iframe*
* **作用结果不同**
  * href 用于在**当前文档和引用资源之间确立联系**
  * src 用于**替换当前内容**

* **浏览器解析方式不同**
  * 若在文档中添加href ，浏览器会识别该文档为 CSS 文件，就会**并行下载资源并且不会停止对当前文档的处理**。这也是为什么建议使用 link 方式加载 CSS，而不是使用 @import 方式
  * 当浏览器解析到src ，会暂停其他资源的下载和处理，直到将**该资源加载、编译、执行完毕，图片和框架等也如此**，类似于将所指向资源应用到当前内容。这也是为什么建议把 js 脚本放在底部而不是头部的原因。





### HTML5 drag api

> 作用域被拖放元素

1. **dragstart**

   在开始拖放被拖放元素时触发

2. **darg**

   在正在拖放被拖放元素时触发

3. **dragend**

   在整个拖放操作结束时触发

> 作用于目标元素

1. dragenter

   在被拖放元素进入某元素时触发

2. dragover

   在被拖放在某元素内移动时触发

3. dragleave

   在被拖放元素移出目标元素是触发

4. drop

   在目标元素完全接受被拖放元素时触发